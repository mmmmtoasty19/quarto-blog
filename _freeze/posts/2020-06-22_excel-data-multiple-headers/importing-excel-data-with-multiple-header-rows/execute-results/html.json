{
  "hash": "60d6633a1e1ff8735446992c72cfebd9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Importing Excel Data with Multiple Header Rows\"\nsubtitle: |\n  A solution for importing Excel Data that contains two header rows.\ndate: 06-22-2020\n---\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n# Problem \n\nRecently I tried to important some Microsoft Excel data into R, and ran into an issue were the data actually had two different header rows. The top row listed a group, and then the second row listed a category within that group.  Searching goggle I couldn't really find a good example of what I was looking for, so I am putting it here in hopes of helping someone else!   \n\n# Example Data\n\nI have created a small Excel file to demonstrate what I am talking about. Download it [here](https://github.com/mmmmtoasty19/kyleb/tree/master/content/post/2020-06-15-importing-excel-data-with-multiple-headers/example_data.xlsx). This is the data from Excel.\n![image of example data](example_data_img1.png)\n\n# Check Data\n\nFirst we will read the file in using the package readxl and view the data without doing anything special to it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)                  # load the readxl library\nlibrary(tidyverse)               # load the tidyverse for manipulating the data\nfile_path <- \"example_data.xlsx\" # set the file path\nds0 <- read_excel(file_path)     # read the file\nds0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 7\n  Name   `Test 1` ...3  ...4  `Test 2` ...6  ...7 \n  <chr>  <chr>    <chr> <chr> <chr>    <chr> <chr>\n1 <NA>   Run 1    Run 2 Run 3 Run 1    Run 2 Run 3\n2 Max    22       23    24    25       26    27   \n3 Phoebe 34       34    32    34       51    12   \n4 Scamp  35       36    21    22       23    24   \n5 Chance 1234     1235  1236  1267     173   1233 \n6 Aimee  420      123   690   42       45    12   \n7 Kyle   22       23    25    26       67    54   \n```\n\n\n:::\n:::\n\n\n# New Header Names\n\n### Step 1\nFirst lets read back the data, this time however with some options.  We will set the n_max equal to 2, to only read the first two rows, and set col_names to FALSE so we do not read the first row as headers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nds1 <- read_excel(file_path, n_max = 2, col_names = FALSE)\nds1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 7\n  ...1  ...2   ...3  ...4  ...5   ...6  ...7 \n  <chr> <chr>  <chr> <chr> <chr>  <chr> <chr>\n1 Name  Test 1 <NA>  <NA>  Test 2 <NA>  <NA> \n2 <NA>  Run 1  Run 2 Run 3 Run 1  Run 2 Run 3\n```\n\n\n:::\n:::\n\n\n### Step 2\nNow that we have our headers lets first transpose them to a vertical matrix using the base function t(), then we will turn it back into a tibble to allow us to use tidyr fill function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- ds1 %>%\n  t() %>%       #transpose to a matrix\n  as_tibble()   #back to tibble\nnames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 2\n  V1     V2   \n  <chr>  <chr>\n1 Name   <NA> \n2 Test 1 Run 1\n3 <NA>   Run 2\n4 <NA>   Run 3\n5 Test 2 Run 1\n6 <NA>   Run 2\n7 <NA>   Run 3\n```\n\n\n:::\n:::\n\n\nNote that tidyr fill can not work row wise, thus the need to flip the tibble so it is long vs wide.\n\n### Step 3\n\nNow we use tidyr fill function to fill the NA's with whatever value it finds above.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- names %>% fill(V1)  #use dplyr fill to fill in the NA's\nnames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 2\n  V1     V2   \n  <chr>  <chr>\n1 Name   <NA> \n2 Test 1 Run 1\n3 Test 1 Run 2\n4 Test 1 Run 3\n5 Test 2 Run 1\n6 Test 2 Run 2\n7 Test 2 Run 3\n```\n\n\n:::\n:::\n\n\n### Step 4\n\nThis is where my data differed from many of the examples I could find online.  Because the second row is also a header we can not just get rid of them.  We can solve this using paste() combined with dplyr mutate to form a new column that combines the first and second column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- names %>%\n  mutate(\n    new_names = paste(V1,V2, sep = \"_\")\n  )\nnames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 3\n  V1     V2    new_names   \n  <chr>  <chr> <chr>       \n1 Name   <NA>  Name_NA     \n2 Test 1 Run 1 Test 1_Run 1\n3 Test 1 Run 2 Test 1_Run 2\n4 Test 1 Run 3 Test 1_Run 3\n5 Test 2 Run 1 Test 2_Run 1\n6 Test 2 Run 2 Test 2_Run 2\n7 Test 2 Run 3 Test 2_Run 3\n```\n\n\n:::\n:::\n\n\n### Step 4a\n\nOne more small clean up task, in the example data the first column header Name, did not have a second label, this has created a name with an NA attached.  We can use stringr to remove this NA.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- names %>% mutate(across(new_names, ~str_remove_all(.,\"_NA\")))\nnames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 3\n  V1     V2    new_names   \n  <chr>  <chr> <chr>       \n1 Name   <NA>  Name        \n2 Test 1 Run 1 Test 1_Run 1\n3 Test 1 Run 2 Test 1_Run 2\n4 Test 1 Run 3 Test 1_Run 3\n5 Test 2 Run 1 Test 2_Run 1\n6 Test 2 Run 2 Test 2_Run 2\n7 Test 2 Run 3 Test 2_Run 3\n```\n\n\n:::\n:::\n\n\n### Step 5\nNow that are new name column is the way we want it, we can use dpylrs pull to return a vector of just that column\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <-  names %>% pull(new_names)\n```\n:::\n\n\n# Final Data\n\nNow that we have a vector of column names lets read in the original file using our new names.  We set the skip argument to 2, to skip the first two rows, and set col_names equal to our vector of names.  Note the last step I used the janitor package to provide names in snake case (the default for the clean names function.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_data <- readxl::read_excel(file_path, col_names = names, skip = 2) %>%\n  janitor::clean_names()\nexample_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 7\n  name   test_1_run_1 test_1_run_2 test_1_run_3 test_2_run_1 test_2_run_2\n  <chr>         <dbl>        <dbl>        <dbl>        <dbl>        <dbl>\n1 Max              22           23           24           25           26\n2 Phoebe           34           34           32           34           51\n3 Scamp            35           36           21           22           23\n4 Chance         1234         1235         1236         1267          173\n5 Aimee           420          123          690           42           45\n6 Kyle             22           23           25           26           67\n# ℹ 1 more variable: test_2_run_3 <dbl>\n```\n\n\n:::\n:::\n\n\n# Other Help\n\nWhile searching for some solutions to my problem I found two good examples, however neither did exactly what I was trying to do.  \n\n1.  This post by Lisa Deburine is pretty close to what I was trying to accomplish and gave me a good starting point.  Read it [here](https://debruine.github.io/posts/multi-row-headers/)\n\n2.  This post by Alison Hill solves a simlar but slightly different problem. In her data the 2nd row is actually metadata not a second set of headers.  Read it [here](https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}